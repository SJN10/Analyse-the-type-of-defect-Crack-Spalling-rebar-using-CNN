# -*- coding: utf-8 -*-
"""crack or rebar or spall.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g51t-g_tvju7VweF1trV56_3hGFOHU_P

# **Importing Libraries**
"""

import os
import cv2
import numpy as np
from tqdm import tqdm
from PIL import Image
import matplotlib.pyplot as plt
from sklearn.utils import shuffle
import seaborn as sns

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential, Model

from keras.layers import Input, Lambda, Dense, Flatten, Activation, Dropout
from keras.preprocessing.image import ImageDataGenerator
from keras.optimizers import RMSprop
from keras.callbacks import EarlyStopping, ReduceLROnPlateau
from keras import applications

"""# Data Visualization"""

train = list(os.walk('drive/MyDrive/train'))

label_names = train[0][1]
dict_labels = dict(zip(label_names, list(range(len(label_names)))))
print(dict_labels)

def dataset(path): 
    images = []
    labels = []
    for folder in tqdm(os.listdir(path)):
        value_of_label = dict_labels[folder] 

        for file in (os.listdir(os.path.join(path, folder))):
            path_of_file = os.path.join(os.path.join(path, folder), file)

            image = cv2.imread(path_of_file)
            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            image = cv2.resize(image, (150, 150))
            images.append(image)
            labels.append(value_of_label)

    images = np.array(images, dtype = 'float32')/255.0
    labels = np.array(labels)

    return images, labels
images, labels = dataset('drive/MyDrive/train')
images, labels = shuffle(images, labels)

images.shape

"""# Total No. of Defect"""

types = train[0][1]
number = []
for _ in range(1, 4):
    number.append(len(train[_][0]))
plt.figure(figsize = (8, 8))
sns.barplot(y = types, x = number);

"""# **Sample images**"""

plt.figure(figsize = (10,10))
for _ in range(25):
    plt.subplot(5, 5, _+1)
    plt.yticks([])
    plt.xticks([])
    plt.grid(False)
    data = images[_]
    plt.xlabel(label_names[labels[_]])
    plt.imshow(data);

"""# **Load images using ImageDatagenerator**"""

image_size = (224, 224)
batch_size = 3
train_datagen = ImageDataGenerator(rescale = 1./255,
                            shear_range = 0.4,
                            zoom_range = 0.4,
                            horizontal_flip = True,
                            vertical_flip = True,
                            validation_split = 0.2)

train_ds = train_datagen.flow_from_directory('drive/MyDrive/train',
                                      target_size = image_size,
                                      batch_size = batch_size,
                                      class_mode = 'categorical',
                                      subset = 'training',
                                      color_mode="rgb",)

val_ds = train_datagen.flow_from_directory('drive/MyDrive/train',
                                      target_size = image_size,
                                      batch_size = batch_size,
                                      class_mode = 'categorical',
                                      subset = 'validation',
                                      color_mode="rgb")

train_ds.class_indices

"""# **Some augmented images**"""

fig, ax = plt.subplots(nrows=1, ncols=5, figsize=(15,15))

for i in range(5):
    image = next(train_ds)[0][0]
    image = np.squeeze(image)
    ax[i].imshow(image)
    ax[i].axis(False)

"""# **Transfer learning**

### **VGG16**
"""

vgg_base = applications.VGG16(weights = 'imagenet', include_top = False, input_shape = (224, 224, 3))
vgg_base.trainable = False

inputs = Input(shape=(224, 224, 3))

x = vgg_base(inputs, training=False)
x = layers.GlobalAveragePooling2D()(x)
x = layers.Dense(1024, activation = 'relu')(x)
x = layers.Dropout(0.5)(x)
outputs = layers.Dense(3, activation = 'sigmoid')(x)
vgg_model = Model(inputs, outputs)
vgg_model.summary

vgg_model.compile(
    optimizer=keras.optimizers.Adam(),
    loss= keras.losses.CategoricalCrossentropy(from_logits = True),
    metrics= [keras.metrics.CategoricalAccuracy()],
)

epochs = 25
vgg_model.fit(train_ds, epochs=epochs, validation_data=val_ds)

vgg_model.save('vgg.hdf5')

"""# **Testing Model on Own Image**"""

def predictor(img, model):
    image = cv2.imread(img)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (224, 224))
    image = np.array(image, dtype = 'float32')/255.0
    plt.imshow(image)
    image = image.reshape(1, 224,224,3)
    
    label_names = train_ds.class_indices
    dict_class = dict(zip(list(range(len(label_names))), label_names))
    clas = model.predict(image).argmax()
    name = dict_class[clas]
    print('The given image is of \nclass: {0} \nDefect Type: {1}'.format(clas, name))

predictor('drive/MyDrive/validation/testCrack4.jpg', vgg_model)

predictor('drive/MyDrive/validation/testSpall5.jpg', vgg_model)

predictor('drive/MyDrive/validation/testCrack2.jpg', vgg_model)

predictor('drive/MyDrive/validation/testRebar5.jpg', vgg_model)

predictor('drive/MyDrive/validation/testRebar3.jpg', vgg_model)

predictor('drive/MyDrive/validation/testSpall4.jpg', vgg_model)

predictor('drive/MyDrive/validation/testCrack3.jpg', vgg_model)